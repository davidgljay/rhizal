const yaml = require('js-yaml');
const Message = require('../models/message');
const GroupThread = require('../models/group_thread');
const Membership = require('../models/membership');


/* 
The function below is the implementation of the parse function in the rhyzal_parser.spec.js file
The function takes in three parameters: yaml_script, step, and vars
  yaml_script:  the yaml script that contains the messages to be sent
  step: the step in the yaml script to be executed
  vars: variables to be replaced in the messages, these are generated by a graphql query with the same name as the script
     vars should contain:
        phone: the phone number of the user
        bot_phone: the phone number of the bot sending the message
The function parses the yaml script, replaces the variables in the messages, and sends the messages using the send_message and send_attachment functions
*/
class RhyzalParser {

    constructor(script_json) {
        let script_obj;
        const {send, set_message_type, send_announcement, send_to_admins} = Message;
        const {set_variable} = Membership;
        this.send_message = send;
        this.send_announcement = send_announcement;
        this.set_message_type = set_message_type;
        this.set_variable = set_variable;
        this.set_group_variable = GroupThread.set_variable;
        this.send_to_admins = send_to_admins;
        this.save_message = Message.create;
        try {
            script_obj = JSON.parse(script_json);
        }
        catch (e) {
            throw new Error('Invalid JSON input ' + e);
        }
        this.script = script_obj;
    }

    async send(step, vars) {
            if (!this.script) {
                throw new Error('Script not initialized');
            }
            if (step == 'done') {
                return;
            };
            if (!this.script[step]) {
                throw new Error('Step missing from script');
            }

            const messages = this.script[step].send;
            const { community_id, id } = vars;
            let recipient = vars.phone;
            let log_message = true;
            if (vars.group_id) {
                recipient = 'group.' + vars.group_id;
                log_message = false;
            };
            for (let i = 0; i < messages.length; i++) {
                //Send a message with an attachement
                // if (messages[i].match(/attach\(([^)]+)\)/)) {

                //     const file = messages[i].match(/attach\(([^)]+)\)/)[1];
                //     //TODO: update to include user_phone number and format properly 
                //     this.send_message('', file);
                // } else {
                    let message = this.insert_variables(messages[i], vars);

                    await this.send_message(community_id, id, recipient, vars.bot_phone, message, log_message);
                // }
            }
    }

    async receive(step, vars) {
        if (!this.script) {
            throw new Error('Script not initialized');
        }
        if (!this.script[step]) {
            throw new Error('Step missing from script');
        }
        if (Array.isArray(this.script[step].on_receive)) {
            for (let i = 0; i < this.script[step].on_receive.length; i++) {
                await this.evaluate_receive(this.script[step].on_receive[i], vars);
            }
        } else {
            await this.evaluate_receive(this.script[step].on_receive, vars);
        }
    }

    async evaluate_receive(script, vars) {
        switch(Object.keys(script)[0]) {
            case 'step':
                const new_step = String(script['step']);
                if (vars.group_id) {
                    await this.set_group_variable(vars.group_id, 'step', new_step);
                } else {
                    await this.set_variable(vars.id, 'step', new_step);
                }
                await this.send(new_step, vars);
                break;
            case 'save_message':
                if (script['save_message'] == 'true') {
                    const {community_id, id, message, signal_timestamp, phone} = vars;
                    await this.save_message(community_id, id, message, signal_timestamp, phone);
                }
                break;
            case 'set_variable':
                //TODO: add tests for setting variable with regex
                if (script['set_variable']['value'].includes('regex')) {
                    const value = this.regex_match(script['set_variable']['value'], vars);
                    await this.set_variable(vars.id, script['set_variable']['variable'], value);
                    vars[script['set_variable']['variable']] = value;
                } else if (vars[script['set_variable']['value']]) {
                    await this.set_variable(vars.id, script['set_variable']['variable'], vars[script['set_variable']['value']]);
                    vars[script['set_variable']['variable']] = vars[script['set_variable']['value']];
                } else {
                    await this.set_variable(vars.id, script['set_variable']['variable'], script['set_variable']['value']);
                    vars[script['set_variable']['variable']] = script['set_variable']['value'];
                }
                break;
            case 'set_group_variable':
                if (!vars.group_id) {
                    throw new Error('Group ID not found in vars');
                }
                if (script['set_group_variable']['value'].includes('regex')) {
                    const value = this.regex_match(script['set_group_variable']['value'], vars);
                    await this.set_group_variable(vars.group_id, script['set_group_variable']['variable'], value);
                    vars[script['set_group_variable']['variable']] = value;
                } else {
                    await this.set_group_variable(vars.group_id, script['set_group_variable']['variable'], script['set_group_variable']['value']);
                    vars[script['set_group_variable']['variable']] = script['set_group_variable']['value'];
                }
                break;
            case 'set_message_type':
                if(!vars.signal_timestamp) {
                    throw new Error('Signal timestamp not found in vars');
                }
                await this.set_message_type(vars.signal_timestamp, script['set_message_type']['type']);
                break;
            case 'send_announcement':
                if (!vars.community_id) {
                    throw new Error('Community ID not found in vars');
                }
                await this.send_announcement(vars.community_id, vars.id);
                break;
            case 'send_to_admins':
                if (!vars.community_id) {
                    throw new Error('Community ID not found in vars');
                }
                const expandedMessage = this.insert_variables(script['send_to_admins']['preamble'], vars) + '\n\n' + vars.message
                await this.send_to_admins(vars.community_id, vars.id, expandedMessage);
                break;
            case 'if': //TODO: add elif to support more complex logic
                if (this.evaluate_condition(script.if, vars)) {
                    if (script.then) {
                        if (Array.isArray(script.then)) {
                            for (let i = 0; i < script.then.length; i++) {
                                await this.evaluate_receive(script.then[i], vars);
                            }
                        } else {
                            await this.evaluate_receive([script.then], vars);
                        }
                    } 
                } else if (script.else) {
                    if (Array.isArray(script.else)) {
                        for (let i = 0; i < script.else.length; i++) {
                            await this.evaluate_receive(script.else[i], vars);
                        }
                    } else {
                        await this.evaluate_receive(script.else, vars);
                    }
                }
                break;
        }

    };

    regex_match(condition, vars) {
        const [full, variable, match] = condition.match(/regex\(([^,]+), ([^)]+)\)/);
        const regex_match = new RegExp((match.trim().slice(1, -1))).exec(vars[variable]);
        if (regex_match) {
            return regex_match[0];
        } else {
            return null;
        }
    }

    evaluate_condition(condition, vars) {
        // If the condition is a regex, evaluate it against a variable
        if (condition.or) {
            for (let i = 0; i < condition.or.length; i++) {
                if (this.evaluate_condition(condition.or[i], vars)) {
                    return true;
                }
            }
            return false;
        } else if (condition.and) {
            for (let i = 0; i < condition.and.length; i++) {
                if (!this.evaluate_condition(condition.and[i], vars)) {
                    return false;
                }
            }
            return true;
        } else  if (condition.match(/regex\(([^)]+)\)/)) {
            const matches = condition.match(/regex\(([^,]+), ([^)]+)\)/);
            const variable = matches[1];
            let match = matches[2];
            if (!vars[variable]) {
                throw new Error('Condition not found in vars for regex');
            }
            if (matches) {
                match.trim();
                if (match.startsWith('/') && match.endsWith('/')) {
                    match = match.slice(1, -1); // Remove the leading and trailing slashes
                    return new RegExp(match, 'i').test(vars[variable]);
                } else {
                    return vars[variable] == vars[match];
                }
            }
        } else {
            // If the condition is a variable, return the value of the variable
            return !!vars[condition];
        }
    };

    insert_variables(message, vars) {
        for (const key in vars) {
            message = message.replace(new RegExp(`{{${key}}}`, 'g'), vars[key]);
        }
        return message;
    }

}

module.exports = RhyzalParser;